# --- Imports and Key Setup (from Quick Start) ---
from encypher.core.unicode_metadata import UnicodeMetadata
from encypher.core.keys import generate_ed25519_key_pair
from cryptography.hazmat.primitives.asymmetric.types import Ed25519PublicKey, Ed25519PrivateKey
from typing import Optional, Dict, Union
import time
from encypher.core.payloads import BasicPayload, ManifestPayload

# Generate a new Ed25519 key pair
private_key: Ed25519PrivateKey
public_key: Ed25519PublicKey
private_key, public_key = generate_ed25519_key_pair()
signer_id_manifest = "manifest-signer-001"

# Store public keys and create a provider function
public_keys_store: Dict[str, Ed25519PublicKey] = { signer_id_manifest: public_key }
def public_key_provider(signer_id: str) -> Optional[Ed25519PublicKey]:
    return public_keys_store.get(signer_id)
# ----------------------------------------------------

# Original text to be signed
original_text = "This is an important statement generated by an AI assistant."

# Embed a C2PA-inspired manifest
# The library automatically calculates the content hash of the original text.
encoded_text_manifest = UnicodeMetadata.embed_metadata(
    text=original_text,
    private_key=private_key,
    signer_id=signer_id_manifest,
    timestamp=int(time.time()),
    metadata_format="cbor_manifest",  # Use the CBOR manifest format ("jumbf" is also supported)
    claim_generator="EncypherAI README Example v2.3",
    actions=[
        {
            "action": "c2pa.created",
            "when": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            "description": "Text was created by an AI model."
        }
    ],
    ai_info={
        "model_id": "gpt-4o-2024-05-13",
        "prompt": "Write a short, important statement."
    }
)

print(f"Text with embedded manifest: '{encoded_text_manifest[:60]}...'")

### Verifying the Manifest and Detecting Tampering

# Verification confirms both the signature's authenticity and the text's integrity. Any change to the original text will cause verification to fail.

# 1. Verify the original, unmodified text
is_valid, signer, payload = UnicodeMetadata.verify_metadata(
    text=encoded_text_manifest,
    public_key_provider=public_key_provider
)

print(f"\nVerification of original text successful: {is_valid}")
if is_valid and payload:
    print(f"  - Signer ID: {signer}")
    # The payload is a ManifestPayload object, so we can access its attributes
    if isinstance(payload, ManifestPayload):
        print(f"  - Claim Generator: {payload.claim_generator}")
        print(f"  - Actions: {payload.actions}")
    # The content hash is stored inside the manifest and checked automatically
    # during verification.

# 2. Attempt to verify tampered text
tampered_text = encoded_text_manifest.replace("important", "unimportant")

is_tampered_valid, _, _ = UnicodeMetadata.verify_metadata(
    text=tampered_text,
    public_key_provider=public_key_provider
)

print(f"\nVerification of tampered text successful: {is_tampered_valid}") # Expected: False
if not is_tampered_valid:
    print("  - As expected, verification failed, indicating the text was tampered with.")
