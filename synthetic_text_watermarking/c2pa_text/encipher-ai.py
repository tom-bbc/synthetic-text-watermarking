import time
from typing import Dict, Optional, Union  # Added Union

from cryptography.hazmat.primitives.asymmetric.types import (
    Ed25519PrivateKey,
    Ed25519PublicKey,
)
from encypher.core.keys import generate_ed25519_key_pair  # Updated to specific key type
from encypher.core.payloads import (  # For type hinting verified_payload
    BasicPayload,
    ManifestPayload,
)
from encypher.core.unicode_metadata import UnicodeMetadata

# --- Key Management (Replace with your actual key management) ---
# Generate a new Ed25519 key pair
private_key: Ed25519PrivateKey
public_key: Ed25519PublicKey
private_key, public_key = generate_ed25519_key_pair()
signer_id_example = "readme-signer-001"  # Using signer_id

# Store public keys (e.g., in a database or secure store)
public_keys_store: Dict[str, Ed25519PublicKey] = {signer_id_example: public_key}


# Create a provider function to look up public keys by ID
def public_key_provider(
    signer_id: str,
) -> Optional[Ed25519PublicKey]:  # Renamed and uses signer_id
    return public_keys_store.get(signer_id)


# -----------------------------------------------------------------

# Core information for embedding
current_timestamp = int(time.time())  # Current Unix timestamp (seconds since epoch)

# Custom metadata payload (user-defined data)
custom_payload = {
    "model_id": "gpt-4o-2024-05-13",
    "source_script": "README_quickstart",
    "user_defined_version": "2.3.0",  # Updated version
}

# Embed metadata and sign
# The 'metadata_format' and 'version' (EncypherAI spec version) parameters for
# embed_metadata default to "basic" and the latest spec version respectively.
encoded_text = UnicodeMetadata.embed_metadata(
    text="This is a sample text generated by an AI model.",
    private_key=private_key,  # Private key for signing
    signer_id=signer_id_example,  # Identifier for the key pair
    custom_metadata=custom_payload,  # Your arbitrary metadata
    omit_keys=["user_id", "session_id"],  # Example of redacting fields
)

# Extract metadata (without verification - returns the raw payload if successful)
# This is useful for quick inspection but does not guarantee authenticity or integrity.
extracted_unverified_payload = UnicodeMetadata.extract_metadata(encoded_text)
print(f"Extracted (unverified) payload: {extracted_unverified_payload}")

# Verify the signature and extract metadata using the public key provider
# This is the recommended way to get trusted metadata.
is_valid: bool
extracted_signer_id: Optional[str]
verified_payload: Union[BasicPayload, ManifestPayload, None]  # Type hint for clarity
is_valid, extracted_signer_id, verified_payload = UnicodeMetadata.verify_metadata(
    text=encoded_text, public_key_provider=public_key_provider
)

print(f"\nSignature valid: {is_valid}")
if is_valid and verified_payload:
    print(f"Verified Signer ID: {extracted_signer_id}")
    print(f"Verified Timestamp: {verified_payload.timestamp}")
    print(f"Verified Custom Metadata: {verified_payload.custom_metadata}")
    print(f"Verified Format: {verified_payload.format}")
    print(f"Verified EncypherAI Spec Version: {verified_payload.version}")
else:
    print("Metadata could not be verified or extracted.")
